import data.real.basic
import algebra.order
import algebra.group_with_zero.basic
import tactic.congr
import tactic.basic
import tactic.lift

theorem IMO_2010_Pb_1 (s:ℝ → ℤ)(f:ℝ→ℝ)
(hs:∀(x:ℝ), ↑(s x) ≤ x)(hs2:∀(x:ℝ),∀(n:ℤ),↑n≤ x→ n≤ s x)
(h:∀ (x y:ℝ), f ((s x) * y)=(f x)*(s (f y))):
(∀ (x:ℝ), f x =0) ∨ (∃(a:ℝ), (∀ (x:ℝ), f x = a)∧ (a<2)∧(1≤a))
:=
begin
  have triv: (1:ℝ)=↑1,
  norm_cast,
  have d00: ∀ (n:ℤ), ↑(s n) = ↑n:=
  begin 
    intro n,
  have d1: ↑(s n)≤ ↑n,
  let h3:=hs,
  specialize h3 n,
  assumption,
  have d20: n ≤ s n,
  let h4:=hs2,
  specialize h4 n n,
  apply h4,
  trivial,
  have d2: ↑n ≤ ↑(s n),
  finish,
  have d3: ↑n≤ ↑(s n) ↔ ↑n = ↑(s n),
  apply has_le.le.le_iff_eq d1,
  have d4: ↑n = ↑(s n),
  rw ← d3,
  assumption,
  symmetry,
  assumption,
  end,
  have h0: f 0 = 0 ∨ ↑(s (f 0)) = (1:ℝ),
  let x1:=0,
  let y1:=0,
  let h2:=h,
  specialize h2 x1 y1,
  --have d1: ∀(x:ℝ), ↑(s x) ≤ x,
  let d4:=d00,
  specialize d4 0,
  have dtest0: (f 0)* (s (f 0)) = f ((s 0)*0),
  symmetry,
  assumption,
  have dtest01: f(↑(s 0)*0) = f(↑(0:ℤ)*0),
  have d4b:  ↑(s 0) = ↑0,
  assumption,
  rw d4b,
  refl,
  have dtest: (f 0)* (s (f 0)) = f 0,
  calc (f 0)* (s (f 0)) =f ((s 0)*0): dtest0
       ... = f (↑(0:ℤ)*0) : dtest01
        ... = f 0 : by rw mul_zero,
  by_cases p0: f 0 =0,
  left,
  assumption,
  right,
  let p1:=p0,
  rw ← div_self p1,
  apply eq_div_of_mul_eq p1 _,
  rw mul_comm,
  assumption,
  cases h0 with p0 p1,
  have d0: f 1 = 0 ∨ ↑(s (f 1)) = ↑1,
  let h3 :=h,
  specialize h3 1 1,
  let d4c0:=d00,
  specialize d4c0 1,
  have spos: (0:ℝ)≤ ↑(s ↑(1:ℤ)),
  rw d4c0,
  simp,
  apply zero_le_one,
  have d4c: s 1 = 1,
  norm_cast at d4c0,
  assumption,
  have dtest0: (f 1)* (s (f 1)) = f ((s 1)*1),
  symmetry,
  assumption,
  have dtest01: f((s 1)*1) = f((1:ℤ)*1),
  rw d4c,
  have dtest: (f 1)* (s (f 1)) = f 1,
  calc (f 1)* (s (f 1)) =f ((s 1)*1): dtest0
       ... = f ((1:ℤ)*1) : by rw dtest01
        ... = f 1 : by simp,
  by_cases y0: f 1 =0,
  left,
  assumption,
  let y1:=y0,
  right,
  have contra: ↑(s (f 1)) =(f 1)/(f 1),
  apply eq_div_of_mul_eq y1 _,
  rw mul_comm,
  assumption,
  have contra2: ↑ (s (f 1)) = (1:ℝ),
  calc ↑(s (f 1)) =(f 1)/(f 1): contra 
       ... = (1:ℝ): by rw div_self y1,
  convert contra2,
  symmetry,
  apply triv,
  cases d0 with y0 y1,
  left,
  intro x,
  let h3:=h,
  specialize h3 1 x,
  have h4: (f 1)*↑(s (f x))=0,
  rw y0,
  rw mul_comm,
  rw mul_zero,
  have h5:f ((s 1)*x) = 0,
  rw ←h4,
  assumption,
  rw ← one_mul x,
  let d5:=d00,
  specialize d5 1,
  have s1: ↑(s (1:ℝ)) = (1:ℝ),
  rw triv,
  assumption,
  rw ← s1,
  assumption,
  have c1: f 1 = (f 2)*s (f (1/2)),
  let h3:=h,
  specialize h3 2 (1/2),
  let d02:=d00,
  specialize d02 2,
  have c2: ↑(s 2) *(1/2) = (1:ℝ),
  have c3: (s ↑2)= s 2,
  simp,
  rw ← c3,
  simp,
  have c4: ↑(s 2) =↑2,
  rw ← c3,
  assumption,
  rw c4,
  simp,
  have h3b: (f 2)*(s (f (1/2)))=f ((s 2)*(1/2)),
  symmetry,
  assumption,
  have hdef: (f 2)*(s (f (1/2)))=f 1,
  have c00: f (↑(s 2)*(1/2)) = f (1:ℝ),
  rw c2,
  calc (f 2)*(s (f (1/2)))=f ((s 2)*(1/2)): h3b
      ... = f 1: by rw c00,
  symmetry,
  assumption,
  have c2: ↑(s (f (1/2))) = f 0,
  let h3:=h,
  specialize h3 (1/2) 1,
  have c4: f ((s (1/2))*1) = (f (1/2)),
  calc f ((s (1/2))*1) = (f (1/2))*(s (f 1)):h3
      ... = (f (1/2))*↑1: by rw y1
      ... = f (1/2): by simp,
  have d0s1: 0≤ s (↑1/2),
  let d0s10:= hs2,
  specialize d0s10 (↑1/2) 0,
  apply d0s10,
  simp,
  apply le_of_lt,
  apply zero_lt_one,
  have d0s2: ↑(s (↑1/2))<(1:ℝ),
  let d0s10:= hs,
  specialize d0s10 (↑1/2),
  have d0s3: ↑1/2<(1:ℝ),
  have dl2: 0<(2:ℝ),
  apply zero_lt_two,
  rw div_lt_one dl2,
  simp,
  apply one_lt_two,
  apply lt_of_le_of_lt d0s10 d0s3,
  have s2: s (↑1/2) ≤ 0,
  have s3: s (↑1/2)<0+1 ↔s (↑1/2) ≤ 0,
  apply int.lt_add_one_iff,
  apply s3.1,
  rw add_comm,
  rw add_zero,
  set k:= s (↑1/2),
  norm_cast at d0s2,
  assumption,
  have s30: s (↑1/2) = 0,
  symmetry,
  apply has_le.le.antisymm d0s1 s2,
  have s3: ↑(s (1/2)) = (0:ℝ),
  norm_cast at s30,
  norm_cast,
  assumption,
  have s4: f 0 = f (1/2),
  rw ← mul_one (0:ℝ),
  rw ← s3,
  apply c4,
  have s5: f(1/2) = 0,
  symmetry,
  rw ← p0,
  assumption,
  rw p0,
  rw s5,
  let h3:=d00,
  specialize h3 0,
  norm_cast at h3,
  norm_cast,
  assumption,
  have c3: ↑(s (f (1/2))) = (0:ℝ),
  rw ←p0,
  assumption,
  have c4: (f 2)*↑(s (f (1/2))) = (0:ℝ),
  rw c3,
  rw mul_zero,
  have c5: f 1 = (0:ℝ),
  rw ← c4,
  assumption,
  have c6: ↑(s (f 1)) = ↑0,
  rw c5,
  let d01:=d00,
  specialize d01 0,
  assumption,
  exfalso,
  have c7: ↑(s (f 1)) ≠ ↑0,
  rw y1,
  simp,
  contradiction,
  have c1: ∀(x:ℝ), f x = f 0,
  intro x,
  let h3:= h,
  specialize h3 x 0,
  rw ← mul_zero ↑(s x),
  symmetry,
  rw ←mul_one (f x),
  rw ← p1,
  assumption,
  have c2: (f 0) *(s (f 0)) = f 0,
  let h3:=h,
  specialize h3 0 0,
  have h4:  (f 0) *(s (f 0)) = f (↑(s 0)*0),
  symmetry,
  assumption,
  calc (f 0) *(s (f 0)) = f (↑(s 0)*0):h4
  ... = f 0 : by rw mul_zero,
  by_cases y0: f 0 = 0,
  left,
  rw ← y0,
  assumption,
  let y1 := y0,
  right,
  have c7: ↑(s (f 0)) = (1:ℝ),
  rw ← div_self y1,
  apply eq_div_of_mul_eq y1 _,
  rw mul_comm,
  assumption,
  existsi (f 0),
  split,
  assumption,
  split,
  swap,
  rw ← c7,
  let hs3:=hs,
  specialize hs3 (f 0),
  assumption,
  by_contra ha,
  have c3: ¬(f 0 < 2)↔f 0≥ 2,
  simp,
  have c4: 2≤ f 0,
  apply has_le.le.ge,
  apply c3.1,
  assumption,
  let hs22:=hs2,
  specialize hs22 (f 0) 2,
  have c5: 2≤ s (f 0),
  apply hs22,
  simp,
  assumption,
  have c8: s (f 0) = 1,
  norm_cast at c7,
  assumption,
  have c6: (2:ℤ) ≤ (1:ℤ),
  calc (2:ℤ)≤ s (f 0) : c5
  ... ≤ (1:ℤ): by rw ←c8,
  have c7: ¬ ((2:ℤ)≤ (1:ℤ)),
  exact dec_trivial,
  contradiction,
  -- have c9: ¬ ((1:ℤ) ≥ (2:ℤ)),
  -- apply le_of_not_le,
  -- apply one_le_two,
end